
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Variabili e Memoria in C &#8212; CS notes 1.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=a681ed88"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'programming_languages/c_language/03_c_variables';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="Funzioni in C" href="02_c_functions.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">CS notes 1.0 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Indice</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../00_programming_languages_overview.html">Linguaggi di Programmazione</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2 current active has-children"><a class="reference internal" href="00_c_overview.html">Introduzione al C</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="01_c_compiler.html">Compilatore C e Hello World</a></li>
<li class="toctree-l3"><a class="reference internal" href="02_c_functions.html">Funzioni in C</a></li>
<li class="toctree-l3 current active"><a class="current reference internal" href="#">Variabili e Memoria in C</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/programming_languages/c_language/03_c_variables.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Variabili e Memoria in C</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#variabili">Variabili</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scope-delle-variabili">Scope delle variabili</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#argomenti-vs-parametri">Argomenti vs Parametri</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ciclo-di-vita-delle-variabili-locali">Ciclo di vita delle variabili locali</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#approfondimento-sulla-memoria">Approfondimento sulla memoria</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#composizione-della-memoria">Composizione della memoria</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lo-stack">Lo Stack</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#a-cosa-serve">A cosa serve</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#come-funziona">Come funziona</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#operazioni-principali">Operazioni principali</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#esempio-pratico">Esempio pratico</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#esempio-con-chiamata-a-funzione">Esempio con chiamata a funzione</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#nota-importante">Nota importante</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#assembly">Assembly</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Esempio pratico</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analisi-dettagliata-del-codice">Analisi dettagliata del codice</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusioni">Conclusioni</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="variabili-e-memoria-in-c">
<h1>Variabili e Memoria in C<a class="headerlink" href="#variabili-e-memoria-in-c" title="Link to this heading">#</a></h1>
<section id="variabili">
<h2>Variabili<a class="headerlink" href="#variabili" title="Link to this heading">#</a></h2>
<p>Le variabili sono delle celle di memoria alle quali noi “andiamo a dare un nome” per poi poterci salvare dei dati specifici.</p>
<p>Possiamo vederle come delle piccole scatole all’interno della nostra memoria al cui interno possiamo andare ad inserire i dati che vogliamo salvare in quel momento.</p>
<p>Proviamo a scrivere un programma che fa la somma di due numeri usando delle variabili locali all’interno del main.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num2</span><span class="p">;</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;The sum of 3 and 4 is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Come vedete, anche per dichiarare una variabile abbiamo utilizzato una sintassi simile a quella di una funzione: prima il tipo e poi subito dopo il nome che vogliamo assegnare alla variabile.</p>
<p>In C è necessario tipare esplicitamente le variabili, cioè prima di andare ad assegnare un valore ad una variabile dobbiamo specificare di che tipo sia quella variabile (a differenza di linguaggi come Python dove una sintassi come <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">5</span></code> è permessa).</p>
<p>Quello che siamo andati a fare all’interno del programma che abbiamo appena scritto consiste essenzialmente in due passaggi che avvengono contemporaneamente: la <strong>dichiarazione</strong> di una variabile <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num1</span></code> e l’<strong>inizializzazione</strong> della variabile ad un valore di partenza che può essere un numero (<code class="docutils literal notranslate"><span class="pre">num1</span> <span class="pre">=</span> <span class="pre">3;</span></code>) oppure un’espressione (<code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">=</span> <span class="pre">num1</span> <span class="pre">+</span> <span class="pre">num2;</span></code>).</p>
<p>Lo stesso programma può essere scritto in altri modi, come ad esempio:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num1</span><span class="p">,</span><span class="w"> </span><span class="n">num2</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>

<span class="w">    </span><span class="n">num1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="n">num2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num2</span><span class="p">;</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;The sum of 3 and 4 is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Questo codice è sostanzialmente identico al codice che abbiamo scritto precedentemente, con l’unica differenza che in questo caso non andiamo ad inizializzare le variabili a nessun valore (che quindi partono da un valore a noi non noto), ma andiamo a fare un’assegnazione di valori successivamente alla dichiarazione.</p>
<section id="scope-delle-variabili">
<h3>Scope delle variabili<a class="headerlink" href="#scope-delle-variabili" title="Link to this heading">#</a></h3>
<p>Tutte le variabili che abbiamo visto hanno uno <strong>scoping locale</strong>, questo significa che esistono solo all’interno della funzione stessa. Per capire meglio questo concetto torniamo all’esempio della funzione sum.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num2</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>

<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num2</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;The operation: 3 + 4 = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In questo caso avremo delle variabili locali all’interno della funzione sum. Cosa succede quindi?</p>
<p>Innanzitutto capiamo come verranno chiamate le funzioni:</p>
<ol class="arabic simple">
<li><p>Essendo l’inizio del programma, verrà chiamato il main</p></li>
<li><p>Dato che printf ha bisogno di tutti gli argomenti per essere richiamato, come seconda funzione chiameremo sum per avere il risultato da passare alla funzione printf</p></li>
<li><p>Chiameremo infine la funzione printf con tutti gli argomenti disponibili</p></li>
</ol>
<p>Ciò si può vedere anche all’interno del file assembly:</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>call    __main  &lt;-- Main
movl    $4, %edx
movl    $3, %ecx
call    sum     &lt;-- Sum
movl    %eax, %edx
leaq    .LC0(%rip), %rax
movq    %rax, %rcx
call    printf  &lt;-- Printf
</pre></div>
</div>
</section>
<section id="argomenti-vs-parametri">
<h3>Argomenti vs Parametri<a class="headerlink" href="#argomenti-vs-parametri" title="Link to this heading">#</a></h3>
<p>È importante distinguere tra:</p>
<ul class="simple">
<li><p><strong>Argomenti</strong>: i valori passati ad una funzione durante una chiamata (es. <code class="docutils literal notranslate"><span class="pre">sum(3,</span> <span class="pre">4)</span></code> → 3 e 4 sono gli argomenti)</p></li>
<li><p><strong>Parametri</strong>: le variabili utilizzate all’interno della funzione per ricevere il valore degli argomenti (es. <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sum(int</span> <span class="pre">num1,</span> <span class="pre">int</span> <span class="pre">num2)</span></code> → num1 e num2 sono i parametri)</p></li>
</ul>
<p>I parametri non sono altro che variabili locali loro stesse.</p>
</section>
<section id="ciclo-di-vita-delle-variabili-locali">
<h3>Ciclo di vita delle variabili locali<a class="headerlink" href="#ciclo-di-vita-delle-variabili-locali" title="Link to this heading">#</a></h3>
<p>Capiamo cosa succede all’interno della memoria quando andiamo a chiamare la funzione sum:</p>
<ol class="arabic simple">
<li><p>Una volta chiamata la funzione, viene allocata della memoria nello stack per le tre variabili num1, num2 e sum. Inizialmente non viene assegnato loro un valore, è come se venissero create “vuote”</p></li>
<li><p>Le variabili continuano ad esistere finché la funzione è in esecuzione, in quanto stanno venendo usate</p></li>
<li><p>Una volta eseguito il return, le variabili locali all’interno della funzione vengono “distrutte”, cioè vengono deallocate dalla memoria e quelle celle di memoria specifiche potranno essere usate per altre chiamate senza rimanere vincolate alle variabili locali precedenti</p></li>
</ol>
<p>In poche parole, le variabili locali sono variabili che vengono create ogni volta che la funzione viene richiamata e rimangono in vita solo durante l’esecuzione della funzione per poi venire “distrutte”.</p>
</section>
</section>
<hr class="docutils" />
<section id="approfondimento-sulla-memoria">
<h2>Approfondimento sulla memoria<a class="headerlink" href="#approfondimento-sulla-memoria" title="Link to this heading">#</a></h2>
<section id="composizione-della-memoria">
<h3>Composizione della memoria<a class="headerlink" href="#composizione-della-memoria" title="Link to this heading">#</a></h3>
<p>Iniziamo chiarendo meglio come è composta la memoria:</p>
<ol class="arabic simple">
<li><p>I <strong>registri</strong> sono delle piccole unità di memoria all’interno del microprocessore che sono in grado di operare ad altissima velocità.</p></li>
<li><p>Un livello intermedio costituito dalle <strong>memorie cache</strong> (L1, L2, L3), che rappresentano un compromesso tra velocità e capacità e servono ad ottimizzare l’accesso tra registri e RAM. Ogni livello lavora come un magazzino: in caso tu voglia il dato all’indirizzo 0x1000, prima verrà cercato in L1, poi in L2, poi in L3 e solo infine nella RAM.</p></li>
<li><p>La <strong>memoria RAM</strong> è un’unità di memorizzazione molto più grande dei registri e delle cache, ma più lenta.</p></li>
<li><p>Nelle architetture tradizionali, quando un dato deve essere elaborato, è necessario che quest’ultimo si trovi all’interno dei registri. Tuttavia, i processori più moderni hanno istruzioni più complesse che permettono di operare direttamente su dati in memoria, anche se internamente il processore utilizza comunque registri temporanei per eseguire le operazioni.</p></li>
</ol>
</section>
<section id="lo-stack">
<h3>Lo Stack<a class="headerlink" href="#lo-stack" title="Link to this heading">#</a></h3>
<p>Lo <strong>stack</strong> (pila) è una regione della memoria RAM organizzata secondo il principio <strong>LIFO</strong> (Last In, First Out - “ultimo ad entrare, primo ad uscire”), come una pila di CD: puoi aggiungere o togliere CD solo dalla cima.</p>
<section id="a-cosa-serve">
<h4>A cosa serve<a class="headerlink" href="#a-cosa-serve" title="Link to this heading">#</a></h4>
<p>Lo stack viene utilizzato principalmente per:</p>
<ol class="arabic simple">
<li><p><strong>Memorizzare variabili locali</strong> delle funzioni</p></li>
<li><p><strong>Salvare indirizzi di ritorno</strong> quando si chiamano funzioni</p></li>
<li><p><strong>Passare parametri</strong> alle funzioni</p></li>
<li><p><strong>Salvare temporaneamente registri</strong> durante l’esecuzione</p></li>
</ol>
</section>
<section id="come-funziona">
<h4>Come funziona<a class="headerlink" href="#come-funziona" title="Link to this heading">#</a></h4>
<p>Il processore usa un registro speciale chiamato <strong>Stack Pointer (SP)</strong> che punta sempre alla “cima” dello stack (l’ultimo elemento inserito).</p>
</section>
<section id="operazioni-principali">
<h4>Operazioni principali<a class="headerlink" href="#operazioni-principali" title="Link to this heading">#</a></h4>
<p>Le operazioni che sono possibili sullo stack permettono di andare a salvare il valore di un registro all’interno dello stack e viceversa in una singola operazione molto veloce.</p>
<ul class="simple">
<li><p><strong>PUSH</strong>: inserisce un dato nello stack</p>
<ul>
<li><p>Decrementa lo stack pointer</p></li>
<li><p>Scrive il dato nella nuova posizione</p></li>
</ul>
</li>
<li><p><strong>POP</strong>: rimuove un dato dallo stack</p>
<ul>
<li><p>Legge il dato dalla posizione corrente</p></li>
<li><p>Incrementa lo stack pointer</p></li>
</ul>
</li>
</ul>
</section>
<section id="esempio-pratico">
<h4>Esempio pratico<a class="headerlink" href="#esempio-pratico" title="Link to this heading">#</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stack iniziale (vuoto):
SP → [____]

PUSH 10:
     [____]
SP → [_10_]

PUSH 20:
     [_10_]
SP → [_20_]

POP (ritorna 20):
SP → [_10_]
     [____]
</pre></div>
</div>
</section>
<section id="esempio-con-chiamata-a-funzione">
<h4>Esempio con chiamata a funzione<a class="headerlink" href="#esempio-con-chiamata-a-funzione" title="Link to this heading">#</a></h4>
<p>Quando chiami una funzione, succede questo:</p>
<ol class="arabic simple">
<li><p>I parametri vengono messi sullo stack (PUSH)</p></li>
<li><p>L’indirizzo di ritorno viene salvato sullo stack (PUSH)</p></li>
<li><p>Le variabili locali della funzione vengono allocate sullo stack</p></li>
<li><p>Quando la funzione termina, tutto viene rimosso dallo stack (POP) e il programma torna all’indirizzo salvato</p></li>
</ol>
</section>
<section id="nota-importante">
<h4>Nota importante<a class="headerlink" href="#nota-importante" title="Link to this heading">#</a></h4>
<p>Lo stack <strong>cresce verso il basso</strong> in memoria (indirizzi decrescenti), cioè quando fai PUSH, lo stack pointer diminuisce.</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="assembly">
<h2>Assembly<a class="headerlink" href="#assembly" title="Link to this heading">#</a></h2>
<p>Ora che abbiamo un’idea di come funziona la memoria all’interno della nostra macchina possiamo andare a vedere come ragiona in assembly il nostro processore per capire meglio come vengono salvati i dati.</p>
<p>Vedremo delle architetture che utilizzano lo stack in maniera principale. Questa non è altro che una convenzione per garantire che gli argomenti vengano sempre accettati perché passati allo stesso modo, anche se il programma che richiama la funzione e quello nel quale si trova la funzione richiamata vengono compilati con compilatori differenti, a patto che l’architettura rimanga la stessa. Questo è anche il motivo per il quale al compilatore basta avere il prototipo della funzione per richiamare correttamente la funzione: dato il prototipo di una funzione, il C saprà come andare a richiamare correttamente quella funzione bastando conoscere l’indirizzo nel quale è registrata.</p>
<p>Ultimo concetto da capire prima di tuffarci all’interno dell’assembly è il <strong>PC</strong> (Program Counter), che altro non è che un registro che salva l’indirizzo dell’istruzione successiva da eseguire. In caso di una chiamata di una funzione, una volta che la funzione ritorna, il programma lo usa per capire da che istruzione riprendere l’esecuzione, visto che quella funzione potrebbe essere chiamata da ovunque nel programma.</p>
<section id="id1">
<h3>Esempio pratico<a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
<p>Prendiamo come esempio questo codice in un’architettura x86 <code class="docutils literal notranslate"><span class="pre">x86</span> <span class="pre">msvc</span> <span class="pre">v19.14</span> <span class="pre">(ex-WINE)</span></code> (<a class="reference external" href="https://godbolt.org">simulatore</a>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num2</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">num1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In assembly vedremo che diventa:</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>_num1$ = 8 ; size = 4
_num2$ = 12 ; size = 4

_sum    PROC
        push    ebp
        mov     ebp, esp
        mov     eax, DWORD PTR _num1$[ebp]
        add     eax, DWORD PTR _num2$[ebp]
        pop     ebp
        ret     0
_sum    ENDP

_main   PROC
        push    ebp
        mov     ebp, esp
        push    4
        push    3
        call    _sum
        add     esp, 8
        pop     ebp
        ret     0
_main   ENDP
</pre></div>
</div>
</section>
<section id="analisi-dettagliata-del-codice">
<h3>Analisi dettagliata del codice<a class="headerlink" href="#analisi-dettagliata-del-codice" title="Link to this heading">#</a></h3>
<p>Prima di iniziare, capiamo le costanti definite:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_num1$</span> <span class="pre">=</span> <span class="pre">8</span></code>: indica che <code class="docutils literal notranslate"><span class="pre">num1</span></code> si trova 8 byte sopra <code class="docutils literal notranslate"><span class="pre">ebp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_num2$</span> <span class="pre">=</span> <span class="pre">12</span></code>: indica che <code class="docutils literal notranslate"><span class="pre">num2</span></code> si trova 12 byte sopra <code class="docutils literal notranslate"><span class="pre">ebp</span></code></p></li>
</ul>
<p>Questi offset sono necessari perché tra <code class="docutils literal notranslate"><span class="pre">ebp</span></code> e i parametri ci sono:</p>
<ul class="simple">
<li><p>Il vecchio <code class="docutils literal notranslate"><span class="pre">ebp</span></code> salvato (4 byte)</p></li>
<li><p>L’indirizzo di ritorno (4 byte)</p></li>
<li><p>Quindi il primo parametro è a <code class="docutils literal notranslate"><span class="pre">ebp</span> <span class="pre">+</span> <span class="pre">8</span></code> e il secondo a <code class="docutils literal notranslate"><span class="pre">ebp</span> <span class="pre">+</span> <span class="pre">12</span></code></p></li>
</ul>
<p>Ora analizziamo passo per passo l’esecuzione con rappresentazioni grafiche dello stack:</p>
<hr class="docutils" />
<p><strong>Stato iniziale</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stack:
        [...]
ESP →   [...]
EBP →   [vecchio ebp del chiamante]
</pre></div>
</div>
<hr class="docutils" />
<p><strong>1. <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">ebp</span></code> (in <code class="docutils literal notranslate"><span class="pre">_main</span></code>)</strong>
Salva il base pointer corrente nello stack.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>push    ebp
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stack:
        [...]
ESP →   [vecchio ebp]  ← salvato
EBP →   [vecchio ebp del chiamante]
</pre></div>
</div>
<p><strong>Cosa succede</strong>: ESP viene decrementato e il valore di EBP viene scritto nella nuova posizione.</p>
<hr class="docutils" />
<p><strong>2. <code class="docutils literal notranslate"><span class="pre">mov</span> <span class="pre">ebp,</span> <span class="pre">esp</span></code> (in <code class="docutils literal notranslate"><span class="pre">_main</span></code>)</strong>
Imposta il nuovo base pointer al valore corrente dello stack pointer.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>mov     ebp, esp
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stack:
        [...]
ESP →   [vecchio ebp]
EBP →   [vecchio ebp]  ← nuovo frame di stack
</pre></div>
</div>
<p><strong>Cosa succede</strong>: Ora EBP punta all’inizio del frame di stack della funzione <code class="docutils literal notranslate"><span class="pre">main</span></code>.</p>
<hr class="docutils" />
<p><strong>3. <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">4</span></code> (in <code class="docutils literal notranslate"><span class="pre">_main</span></code>)</strong>
Inserisce il secondo parametro (4) nello stack.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>push    4
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stack:
        [vecchio ebp]
ESP →   [4]            ← secondo parametro
EBP →   [vecchio ebp]
</pre></div>
</div>
<p><strong>Nota</strong>: I parametri vengono inseriti in ordine inverso (da destra a sinistra) per garantire che il primo parametro sia più vicino a EBP.</p>
<hr class="docutils" />
<p><strong>4. <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">3</span></code> (in <code class="docutils literal notranslate"><span class="pre">_main</span></code>)</strong>
Inserisce il primo parametro (3) nello stack.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>push    3
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stack:
        [vecchio ebp]
        [4]            ← num2
ESP →   [3]            ← num1
EBP →   [vecchio ebp]
</pre></div>
</div>
<hr class="docutils" />
<p><strong>5. <code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">_sum</span></code> (in <code class="docutils literal notranslate"><span class="pre">_main</span></code>)</strong>
Chiama la funzione <code class="docutils literal notranslate"><span class="pre">sum</span></code>. Questo salva automaticamente l’indirizzo di ritorno (PC) nello stack e salta alla funzione.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>call    _sum
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stack:
        [vecchio ebp]
        [4]            ← num2 (a EBP + 12 della funzione sum)
        [3]            ← num1 (a EBP + 8 della funzione sum)
ESP →   [indirizzo di ritorno (PC)]
EBP →   [vecchio ebp]
</pre></div>
</div>
<p><strong>Cosa succede</strong>: Il processore salva l’indirizzo dell’istruzione successiva (dopo <code class="docutils literal notranslate"><span class="pre">call</span></code>) nello stack e salta all’inizio di <code class="docutils literal notranslate"><span class="pre">_sum</span></code>.</p>
<hr class="docutils" />
<p><strong>6. <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">ebp</span></code> (in <code class="docutils literal notranslate"><span class="pre">_sum</span></code>)</strong>
La funzione <code class="docutils literal notranslate"><span class="pre">sum</span></code> salva il base pointer di <code class="docutils literal notranslate"><span class="pre">main</span></code>.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>push    ebp
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stack:
        [vecchio ebp di main]
        [4]            ← num2 (a EBP + 12)
        [3]            ← num1 (a EBP + 8)
        [indirizzo di ritorno]  ← (a EBP + 4)
ESP →   [ebp di main]  ← (diventerà il nuovo EBP)
EBP →   [vecchio ebp di main]
</pre></div>
</div>
<hr class="docutils" />
<p><strong>7. <code class="docutils literal notranslate"><span class="pre">mov</span> <span class="pre">ebp,</span> <span class="pre">esp</span></code> (in <code class="docutils literal notranslate"><span class="pre">_sum</span></code>)</strong>
Imposta il nuovo base pointer per la funzione <code class="docutils literal notranslate"><span class="pre">sum</span></code>.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>mov     ebp, esp
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stack:
        [vecchio ebp di main]
        [4]            ← num2 (a EBP + 12)
        [3]            ← num1 (a EBP + 8)
        [indirizzo di ritorno]  ← (a EBP + 4)
ESP →   [ebp di main]  ← (a EBP + 0)
EBP →   [ebp di main]  ← nuovo frame di stack per sum
</pre></div>
</div>
<p><strong>Importante</strong>: Ora possiamo capire gli offset:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EBP</span> <span class="pre">+</span> <span class="pre">0</span></code>: vecchio EBP salvato</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EBP</span> <span class="pre">+</span> <span class="pre">4</span></code>: indirizzo di ritorno</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EBP</span> <span class="pre">+</span> <span class="pre">8</span></code>: primo parametro (<code class="docutils literal notranslate"><span class="pre">num1</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EBP</span> <span class="pre">+</span> <span class="pre">12</span></code>: secondo parametro (<code class="docutils literal notranslate"><span class="pre">num2</span></code>)</p></li>
</ul>
<hr class="docutils" />
<p><strong>8. <code class="docutils literal notranslate"><span class="pre">mov</span> <span class="pre">eax,</span> <span class="pre">DWORD</span> <span class="pre">PTR</span> <span class="pre">_num1$[ebp]</span></code> (in <code class="docutils literal notranslate"><span class="pre">_sum</span></code>)</strong>
Carica il primo parametro nel registro EAX.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>mov     eax, DWORD PTR _num1$[ebp]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Registri:
EAX = 3  ← caricato da [EBP + 8]

Stack:
        [vecchio ebp di main]
        [4]            ← num2
        [3]            ← num1 (letto)
        [indirizzo di ritorno]
ESP →   [ebp di main]
EBP →   [ebp di main]
</pre></div>
</div>
<p><strong>Cosa succede</strong>: Il valore all’indirizzo <code class="docutils literal notranslate"><span class="pre">EBP</span> <span class="pre">+</span> <span class="pre">8</span></code> (che è 3) viene copiato in EAX.</p>
<hr class="docutils" />
<p><strong>9. <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">eax,</span> <span class="pre">DWORD</span> <span class="pre">PTR</span> <span class="pre">_num2$[ebp]</span></code> (in <code class="docutils literal notranslate"><span class="pre">_sum</span></code>)</strong>
Aggiunge il secondo parametro ad EAX.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>add     eax, DWORD PTR _num2$[ebp]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Registri:
EAX = 7  ← 3 + 4

Stack:
        [vecchio ebp di main]
        [4]            ← num2 (letto)
        [3]            ← num1
        [indirizzo di ritorno]
ESP →   [ebp di main]
EBP →   [ebp di main]
</pre></div>
</div>
<p><strong>Cosa succede</strong>: Il valore all’indirizzo <code class="docutils literal notranslate"><span class="pre">EBP</span> <span class="pre">+</span> <span class="pre">12</span></code> (che è 4) viene sommato ad EAX. Risultato: 3 + 4 = 7.</p>
<hr class="docutils" />
<p><strong>10. <code class="docutils literal notranslate"><span class="pre">pop</span> <span class="pre">ebp</span></code> (in <code class="docutils literal notranslate"><span class="pre">_sum</span></code>)</strong>
Ripristina il base pointer di <code class="docutils literal notranslate"><span class="pre">main</span></code>.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>pop     ebp
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Registri:
EAX = 7  ← valore di ritorno

Stack:
        [vecchio ebp di main]
        [4]
        [3]
ESP →   [indirizzo di ritorno]
EBP →   [vecchio ebp di main]  ← ripristinato
</pre></div>
</div>
<p><strong>Cosa succede</strong>: Il valore salvato viene ripristinato in EBP e ESP viene incrementato.</p>
<hr class="docutils" />
<p><strong>11. <code class="docutils literal notranslate"><span class="pre">ret</span> <span class="pre">0</span></code> (in <code class="docutils literal notranslate"><span class="pre">_sum</span></code>)</strong>
Ritorna alla funzione chiamante.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>ret     0
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Registri:
EAX = 7  ← valore di ritorno mantenuto

Stack:
        [vecchio ebp di main]
        [4]
ESP →   [3]
EBP →   [vecchio ebp di main]
</pre></div>
</div>
<p><strong>Cosa succede</strong>: Il processore fa il pop dell’indirizzo di ritorno e salta a quell’indirizzo (torna in <code class="docutils literal notranslate"><span class="pre">main</span></code> dopo la <code class="docutils literal notranslate"><span class="pre">call</span></code>). Il <code class="docutils literal notranslate"><span class="pre">0</span></code> indica che non ci sono parametri da pulire dallo stack (viene fatto dal chiamante).</p>
<hr class="docutils" />
<p><strong>12. <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">esp,</span> <span class="pre">8</span></code> (in <code class="docutils literal notranslate"><span class="pre">_main</span></code>)</strong>
Libera lo spazio utilizzato dai parametri.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>add     esp, 8
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Registri:
EAX = 7  ← valore di ritorno ancora presente

Stack:
ESP →   [vecchio ebp di main]
EBP →   [vecchio ebp di main]
</pre></div>
</div>
<p><strong>Cosa succede</strong>: ESP viene incrementato di 8 byte per “rimuovere” i due parametri da 4 byte ciascuno (3 e 4) che erano stati pushati prima della chiamata.</p>
<hr class="docutils" />
<p><strong>13. <code class="docutils literal notranslate"><span class="pre">pop</span> <span class="pre">ebp</span></code> (in <code class="docutils literal notranslate"><span class="pre">_main</span></code>)</strong>
Ripristina il base pointer originale.</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>pop     ebp
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Registri:
EAX = 7  ← valore di ritorno

Stack:
ESP →   [...]
EBP →   [vecchio ebp del chiamante]  ← ripristinato
</pre></div>
</div>
<hr class="docutils" />
<p><strong>14. <code class="docutils literal notranslate"><span class="pre">ret</span> <span class="pre">0</span></code> (in <code class="docutils literal notranslate"><span class="pre">_main</span></code>)</strong>
Ritorna al chiamante di <code class="docutils literal notranslate"><span class="pre">main</span></code> (tipicamente il sistema operativo).</p>
<div class="highlight-assembly notranslate"><div class="highlight"><pre><span></span>ret     0
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Registri:
EAX = 7  ← valore di ritorno finale
</pre></div>
</div>
<p><strong>Cosa succede</strong>: Il programma termina restituendo 7 (il risultato di <code class="docutils literal notranslate"><span class="pre">sum(3,</span> <span class="pre">4)</span></code>).</p>
</section>
<hr class="docutils" />
<section id="conclusioni">
<h3>Conclusioni<a class="headerlink" href="#conclusioni" title="Link to this heading">#</a></h3>
<p>Questo esempio fa capire perfettamente:</p>
<ul class="simple">
<li><p>Come funziona lo stack nelle chiamate a funzione</p></li>
<li><p>Cosa sono le <strong>variabili locali</strong> in C (valori temporanei salvati nello stack)</p></li>
<li><p>Come vengono passati i <strong>parametri</strong> alle funzioni</p></li>
<li><p>Come funziona il <strong>ritorno da una funzione</strong> e il ripristino dello stack</p></li>
<li><p>Perché i parametri vengono inseriti in <strong>ordine inverso</strong> (per mantenere l’ordine corretto rispetto a EBP)</p></li>
</ul>
<p>Ogni volta che il nostro programma richiamerà un’altra funzione, questo processo avverrà di nuovo, creando nuovi frame di stack che si sovrappongono temporaneamente, per poi essere rimossi al termine di ogni funzione.</p>
<br>
<!-- Versions and languages set-up -->
<style>
  .fixed-bar {
    position: fixed;
    bottom: 10px;
    right: 10px;
    background: rgba(240, 240, 240, 0.85);
    border: 1px solid rgba(100, 100, 100, 0.3);
    border-radius: 6px;
    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 0.9rem;
    color: #222;
    display: flex;
    gap: 12px;
    padding: 6px 12px;
    align-items: center;
    z-index: 9999;
    backdrop-filter: saturate(180%) blur(10px);
  }

  @media print {
    .fixed-bar {
      display: none !important;
    }
  }

  .fixed-bar .dropdown {
    position: relative;
    user-select: none;
  }

  .fixed-bar .dropdown-toggle {
    background-color: rgba(200, 200, 200, 0.4);
    color: #222;
    padding: 6px 10px;
    border: 1px solid rgba(100, 100, 100, 0.3);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    white-space: nowrap;
    transition: background-color 0.3s ease;
  }

  .fixed-bar .dropdown-toggle::after {
    content: none !important;
    display: none !important;
  }

  .fixed-bar .dropdown-toggle:hover {
    background-color: rgba(100, 150, 220, 0.2);
    color: #1a3e72;
    border-color: rgba(26, 62, 114, 0.6);
  }

  .fixed-bar .dropdown-toggle .fa {
    font-size: 0.9rem;
  }

  .fixed-bar .dropdown-menu {
    position: absolute;
    bottom: 100%;
    left: 0;
    background-color: rgba(250, 250, 250, 0.95);
    border: 1px solid rgba(150, 150, 150, 0.3);
    border-radius: 4px;
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
    min-width: 140px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
    flex-direction: column;
    z-index: 10000;
    backdrop-filter: saturate(180%) blur(8px);
  }

  .fixed-bar .dropdown-menu.show {
    display: flex;
  }

  .fixed-bar .dropdown-menu a {
    padding: 8px 12px;
    color: #1a3e72;
    text-decoration: none;
    border-bottom: 1px solid rgba(200, 200, 200, 0.5);
    white-space: nowrap;
    transition: background-color 0.25s ease;
  }

  .fixed-bar .dropdown-menu a:last-child {
    border-bottom: none;
  }

  .fixed-bar .dropdown-menu a:hover {
    background-color: rgba(100, 150, 220, 0.15);
  }
</style>
<div class="fixed-bar" role="region" aria-label="Version and language selector">
  <div class="dropdown">
    <div class="dropdown-toggle" tabindex="0" aria-haspopup="listbox" aria-expanded="false">
      <span class="fa fa-book" aria-hidden="true"></span>
      Version: <span class="current-value">V. 1.0</span>
      <span class="fa caret-icon fa-caret-down" aria-hidden="true"></span>
    </div>
    <div class="dropdown-menu" role="listbox">
      	<a href="#" role="option">V. 1.0</a>
    </div>
  </div>
  <div class="dropdown">
    <div class="dropdown-toggle" tabindex="0" aria-haspopup="listbox" aria-expanded="false">
      <span class="fa fa-globe" aria-hidden="true"></span>
      Language: <span class="current-value">Italiano</span>
      <span class="fa caret-icon fa-caret-down" aria-hidden="true"></span>
    </div>
    <div class="dropdown-menu" role="listbox">
      	<a href="#" role="option">English</a>
				<a href="#" role="option">Italiano</a>
    </div>
  </div>
</div>
<script>
document.addEventListener("DOMContentLoaded", () => {

  const bar = document.querySelector('.fixed-bar');
  const dropdowns = bar.querySelectorAll('.dropdown');
  const defaultLang = 'English';
  const languages = ["English", "Italiano"];
  const versions = ["V. 1.0"];

  // ---------------------------
  // Helpers
  // ---------------------------

  function closeAll() {
    dropdowns.forEach(d => {
      d.querySelector('.dropdown-menu').classList.remove('show');
      const t = d.querySelector('.dropdown-toggle');
      t.setAttribute('aria-expanded', 'false');
      const caret = t.querySelector('.caret-icon');
      if (caret) {
        caret.classList.remove('fa-caret-up');
        caret.classList.add('fa-caret-down');
      }
    });
  }

  function toggleMenu(dropdown) {
    const toggle = dropdown.querySelector('.dropdown-toggle');
    const menu = dropdown.querySelector('.dropdown-menu');
    const isOpen = toggle.getAttribute('aria-expanded') === 'true';

    closeAll();
    if (!isOpen) {
      menu.classList.add('show');
      toggle.setAttribute('aria-expanded', 'true');
      const caret = toggle.querySelector('.caret-icon');
      if (caret) {
        caret.classList.remove('fa-caret-down');
        caret.classList.add('fa-caret-up');
      }
    }
  }

  async function pathExists(path) {
    try {
      const r = await fetch(path, { method: 'HEAD' });
      return r.ok;
    } catch {
      return false;
    }
  }

  async function resolvePath(segments, newLang, newVer) {
    const seg = [...segments];

    const langIndex = seg.findIndex(s => languages.includes(decodeURIComponent(s)));
    const verIndex = seg.findIndex(s => versions.includes(decodeURIComponent(s)));

    if (newLang) seg[langIndex] = encodeURIComponent(newLang);
    if (newVer) seg[verIndex] = encodeURIComponent(newVer);

    const primary = "/" + seg.join("/");

    if (await pathExists(primary)) return primary;

    // Fallback: default language
    if (newLang) {
      seg[langIndex] = encodeURIComponent(defaultLang);
    }
    const fallback = "/" + seg.join("/");
    if (await pathExists(fallback)) return fallback;

    // Last fallback -> /version/language/index.html
    return `/${seg[0]}/${seg[1]}/index.html`;
  }

  // ---------------------------
  // Events
  // ---------------------------

  dropdowns.forEach(dropdown => {
    const toggle = dropdown.querySelector('.dropdown-toggle');
    const menu = dropdown.querySelector('.dropdown-menu');
    const display = dropdown.querySelector('.current-value');

    toggle.addEventListener('click', e => {
      e.stopPropagation();
      toggleMenu(dropdown);
    });

    menu.querySelectorAll('a').forEach(link => {
      link.addEventListener('click', async e => {
        e.preventDefault();

        const selected = link.textContent.trim();
        display.textContent = selected;

        const segments = window.location.pathname.split("/").filter(Boolean);

        const isLang = toggle.textContent.includes("Language");
        const isVer = toggle.textContent.includes("Version");

        let newLang = null, newVer = null;

        if (isLang) newLang = selected;
        if (isVer) {
          newVer = versions.find(v => v.endsWith(selected)) || selected;
        }

        const newPath = await resolvePath(segments, newLang, newVer);
        window.location.pathname = newPath;
      });
    });
  });

  // Outside click closes all
  window.addEventListener('click', closeAll);

  // Escape closes all
  window.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeAll();
  });

});

/*
Silly ahh frog for good luck ~ Niccolò Quadrani

      (')-=-(')
    __(   "   )__   ~ cra cra brother
  / _/'-----'\_ \
___\\ \\     // //___
>____)/_\---/_\(____<

*/


</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"></section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="02_c_functions.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Funzioni in C</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#variabili">Variabili</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scope-delle-variabili">Scope delle variabili</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#argomenti-vs-parametri">Argomenti vs Parametri</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ciclo-di-vita-delle-variabili-locali">Ciclo di vita delle variabili locali</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#approfondimento-sulla-memoria">Approfondimento sulla memoria</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#composizione-della-memoria">Composizione della memoria</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lo-stack">Lo Stack</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#a-cosa-serve">A cosa serve</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#come-funziona">Come funziona</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#operazioni-principali">Operazioni principali</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#esempio-pratico">Esempio pratico</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#esempio-con-chiamata-a-funzione">Esempio con chiamata a funzione</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#nota-importante">Nota importante</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#assembly">Assembly</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Esempio pratico</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analisi-dettagliata-del-codice">Analisi dettagliata del codice</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusioni">Conclusioni</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Niccolò Quadrani
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025, Niccolò Quadrani.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>